Core Concepts
==============================================================

Lifecycle of a Mini App
---------------------------

Since your mini app is running in a hosted environment, it is important to understand the 
lifecycle in order for proper integration to occur. The following image illustrates this lifecycle in general.

.. image:: /images/lifecycle.jpg

.. _core_concepts_events:

Events generated by the Host App
-----------------------------------

There are certain events that are generated by the host app that are necessary to be handled by 
your mini app:

#. ``onData`` - This event occurs once after your mini app has loaded and when the AQ Host app sends additional information that is 
   relevant in the current invocation of your mini app. (ex. the current user). Most of the time, 
   the data passed by this event is necessary for the setup of your mini app (ex. different setup 
   depending on the type of user invoking your mini app). Data with the following JSON schema is 
   passed when this event is invoked:

  .. code-block:: json 

    {
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "userInfo": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            },
            "displayName": {
              "type": "string"
            },
            "avatarBig": {
              "type": "string",
              "format": "uri"
            },
            "avatarSmall": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "id",
            "displayName",
            "avatarBig",
            "avatarSmall"
          ]
        }
      },
      "type": "object",
      "properties": {
        "shouldWin": {
          "type": "boolean"
        },
        "winImage": {
          "type": "string",
          "format": "uri"
        },
        "source": {
          "$ref": "#/definitions/userInfo"
        },
        "engagementSource": {
          "$ref": "#/definitions/userInfo"
        },
        "engagementInfo": {
          "type": "object"      
        },
        "targetScore": {
          "type": "number"
        },
        "difficultyLevel": {
          "type": "number",
          "minimum: 0,
          "maximum": 4
        }
      },
      "required": [
        "shouldWin",
        "source",
        "engagementSource"
      ]
    }

  Fields are described as follows:

  * ``shouldWin`` - Tells the mini app to force the current game iteration to win
  * ``winImage`` - Optional. Image URL of item won. Only present if ``shouldWin`` is true.
  * ``source`` - User info of current user playing the mini app
  * ``engagementSource`` - User info of user who created the instance of the mini app
  * ``engagementInfo`` - Data specific to the mini app.
  * ``targetScore`` - An optional score that the user must attain in order for the current game to be considered as a win. If this data is present, the mini app must accomodate it's UI to inform this user of this specific 
target score.
  * ``difficultyLevel`` - Tells the mini app how difficult the game should proceed. This is in an integer from 0 (easiest) to 4 (hardest). A difficultyLevel of 2 should represent a normal difficulty level.

  An example of the data passed by ``onData`` is as follows:

  .. code-block:: json

    {
      "shouldWin": true,
      "winImage": "http://example.com/example.jpg",
      "source": {
        "id": "some_id",
        "displayName": "Bob",
        "avatarBig": "http://example.com/example.jpg",
        "avatarSmall": "http://example.com/example.jpg"
      },
      "engagementSource": {
        "id": "some_id",
        "displayName": "Alice",
        "avatarBig": "http://example.com/example.jpg",
        "avatarSmall": "http://example.com/example.jpg"
      },
      "engagementInfo": {
        "opponent": {
          "id": "some_id",
          "displayName": "Carol",
          "avatarBig": "http://example.com/example.jpg",
          "avatarSmall": "http://example.com/example.jpg"
        },
        "choice": 0,
        "betAmount": 5
      },
      "targetScore": 20,
      "difficultyLevel": 2
    }

#. ``onReset`` - This event is triggered when the AQ Host app requests that your mini app reset to
   the initial game state with data of the same schema as ``onData`` is passed. Although it is 
   possibe that the same data as one on ``onData`` may be passed, it is not safe to assume that this
   is always the case.

   Unlike ``onData``, which is only called right after your mini app is loaded, ``onReset`` may be 
   called several times during the lifetime of your mini app.

.. _core_concepts_callbacks:

Setting Callback Handlers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In order to receive events generated by the host app, you need to setup certain callback functions.
This can be achieved by calling several ``LifeCycle`` methods. You usually call these methods
as early as possible, primarily in your init or constructor of your main function.

* ``LifeCycle.setOnDataCallback()`` - Sets the handler for the ``onData`` event. This function
  accepts a callback function as a parameter.

* ``LifeCycle.setOnResetCallback()`` - Sets the handler for the ``onReset`` event. This function
  accepts a callback function as a parameter.   

Example usage:

.. code-block:: javascript

  var LifeCycle = AQCore.LifeCycle;

  var onData = function(data) {
    // Do something with the data
  }

  var onReset = function(newData) {
    // Do something with the new data
    // and reset app to initial state
  }

  LifeCycle.setOnDataCallback(onData);
  LifeCycle.setOnResetCallback(onReset);

.. code-block:: javascript

  // ES6 syntax
  import { LifeCycle } from 'aq-miniapp-core';

  class MyGame {
    constructor() {
      LifeCycle.setOnDataCallback(this.onData.bind(this));
      LifeCycle.setOnDataCallback(this.onReset.bind(this));
    }

    onData(data) {
      // Do something with the data
    }

    onReset(newData) {
      // Do something with the new data
      // and reset app to initial state
    }  
  }


Information needed by the Host App
-----------------------------------

The Host app will need several information from your mini app in every invocation. It needs to know:

#. **A URL of an image that it can use as a background** - The Host app also shows certain screens with customized background
   which is relevant to the current mini app being run. You should give this information the Host app in a form of a valid 
   image URL, otherwise, no background will be used.
   
#. **When your app is ready to be displayed** - When the Host App loads your mini app, it doesn't immediately
   show it. It shows a preloader screen while waiting for it to finish any necessary setup (like loading of assets such
   as images our sound files), so it is necessary for your mini app to tell the Host app that it is safe to remove
   the preloader screen and show it to the user.

#. **When the result from your mini app is already available and your gameplay is about to end** - The result from your mini app
   (such as the score, or the player won or not)

#. **When your app should end** - Once the game play of your app has ended, you should inform the Host app about this, so it can
   display succeeding screens.

You can achieve these by calling several ``LifeCycle`` functions.

#. ``LifeCycle.setAppData()`` - This function expects a JSON object that the Host app will receive and process
   accordingly. Currently, the schema only allows passing the URL of the image to be used by the Host app as a background. 
   You normally will call this during the initialization of your mini app. The JSON schema is as follows:

   .. code-block:: json 

    {
      "$schema": "http://json-schema.org/draft-04/schema#",
      "type": "object",
      "properties": {
        "backgroundImage": {
          "type": "string",
          "format": "uri"
        }
      },
      "required": [
        "backgroundImage"
      ]
    }

  Example usage:

   .. code-block:: javascript

     var LifeCycle = AQCore.LifeCycle;

     function init() {
       LifeCycle.setOnDataCallback({ backgroundImage: 'http://example.com/example.jpg' });
     }

   .. code-block:: javascript

     // ES6 syntax
     import { LifeCycle } from 'aq-miniapp-core';

     class MyGame {
       constructor() {
         LifeCycle.setOnDataCallback({ backgroundImage: 'http://example.com/example.jpg' });
       }
     }
    
#. ``LifeCycle.informReady()`` - This function tells the Host app to display the mini app immediately. 
   Call this when you already have setup your resources and your mini app is ready to be displayed.

   Example usage:

   .. code-block:: javascript

     var LifeCycle = AQCore.LifeCycle;

     // An example function that is called after all the assets has been loaded
     function onLoadAssets() {
       LifeCycle.informReady();
     }

   .. code-block:: javascript

     // ES6 syntax
     import { LifeCycle } from 'aq-miniapp-core';

     class MyGame {
      
       // An example function that is called after all the assets has been loaded
       onLoadAssets() {
         LifeCycle.informReady();
       }  
     }

#. ``LifeCycle.setResult()`` - This function tells the Host app that the result for the current invocation of your mini app 
   is available, but the mini app itself has not yet ended. The host app needs the following information:

      * Whether the current game invocation is a win, lose, or draw. Can be one of the following constants exposed by ``AQCore``:

        #. ``WIN_CRITERIA_WIN`` or (``WinCriteriaEnum.Win`` for ES6)
        #. ``WIN_CRITERIA_LOSE`` or (``WinCriteriaEnum.Lose`` for ES6)
        #. ``WIN_CRITERIA_DRAW`` or (``WinCriteriaEnum.Draw`` for ES6)

      * The final game score either as a constant or a actual-target component (e.g. 10 out of 20).
      * An image result for your gameplay (e.g. a screenshot with the score) as a valid URL.

   Example usage:

   .. code-block:: javascript

     var AQCore = window.AQCore;
     var LifeCycle = AQCore.LifeCycle;

     // An example function that is called when your game (mini app)'s result is available
     function onScoreAvailable(score) {
       var param = {
        // General game result  
        winCriteria: AQCore.WIN_CRITERIA_WIN,
        // Score of the game. This field is optional if it is 
        // not logical for the game to have a score
        score: {
          value: score
        },
        // A valid image url, (usually a screenshot) of the game result
        resultImageUrl: 'http://example.com/example.jpg'
       }

       // You can also specify the score as an actual-target value like this:
       //
       // score: {
       //   value: 10,
       //   target: 20
       // }
       // 

       LifeCycle.setResult(param);
     }

   .. code-block:: javascript

     // ES6 syntax
     import { LifeCycle, WinCriteriaEnum } from 'aq-miniapp-core';

     class MyGame {
      
      // An example function that is called when your game (mini app)'s result is available
      onScoreAvailable(score) {
         var param = {
            // General game result  
            winCriteria: WinCriteriaEnum.Win,
            // Score of the game. This field is optional if it is 
            // not logical for the game to have a score
            score: {
              value: score
            },
            // A valid image url, (usually a screenshot) of the game result
            resultImageUrl: 'http://example.com/example.jpg'
         }

         // You can also specify the score as an actual-target value like this:
         //
         // score: {
         //   value: 10,
         //   target: 20
         // }
         // 
         LifeCycle.setResult(param);
       }  
     }

#. ``LifeCycle.end()`` - This function tells the Host app that the current invocation of your mini app has 
   ended, usually when your game is over. When this is called, you signal the Host app that it can already display
   succeeding screens relevant to the current game play. Moreover, your mini app should ensure that no sound
   is playing after this method is called. The only time where the game sounds can be played again is when 
   the ``onReset`` event is triggered.

   Example usage:

   .. code-block:: javascript

     var LifeCycle = AQCore.LifeCycle;

     // An example function that is called when your game (mini app) has ended
     function onGameEnd() {
       LifeCycle.end();
       
       // Ensure game sounds are disabled at this point
     }

   .. code-block:: javascript

     // ES6 syntax
     import { LifeCycle } from 'aq-miniapp-core';

     class MyGame {
      
       // An example function that is called when your game (mini app) has ended
       onGameEnd() {
         LifeCycle.end();

         // Ensure game sounds are disabled at this point
       }  
     }

  